# Secret Rotation Pipeline with External Secrets Operator

name: Secret Rotation Pipeline
on:
  schedule:
    # Run every Sunday at 2 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      rotation_type:
        description: 'Type of rotation to perform'
        required: true
        default: 'database'
        type: choice
        options:
        - database
        - api-keys
        - certificates
        - all

env:
  AWS_REGION: us-east-1
  CLUSTER_NAME: production-eks

jobs:
  pre-rotation-checks:
    name: Pre-Rotation Health Checks
    runs-on: ubuntu-latest
    outputs:
      can_proceed: ${{ steps.health_check.outputs.healthy }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: secret-rotation-session
      
      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }}
          kubectl version --client
      
      - name: Health check applications
        id: health_check
        run: |
          # Check if all deployments are ready
          deployments_ready=$(kubectl get deployments -A -o jsonpath='{.items[?(@.status.readyReplicas==@.status.replicas)].metadata.name}' | wc -w)
          total_deployments=$(kubectl get deployments -A --no-headers | wc -l)
          
          echo "Ready deployments: $deployments_ready / $total_deployments"
          
          if [ "$deployments_ready" -eq "$total_deployments" ]; then
            echo "healthy=true" >> $GITHUB_OUTPUT
            echo "✅ All applications are healthy, proceeding with rotation"
          else
            echo "healthy=false" >> $GITHUB_OUTPUT
            echo "❌ Some applications are unhealthy, aborting rotation"
            exit 1
          fi

  rotate-database-secrets:
    name: Rotate Database Secrets
    runs-on: ubuntu-latest
    needs: pre-rotation-checks
    if: needs.pre-rotation-checks.outputs.can_proceed == 'true' && (github.event.inputs.rotation_type == 'database' || github.event.inputs.rotation_type == 'all' || github.event.schedule)
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }}
      
      - name: Generate new database password
        id: generate_password
        run: |
          NEW_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)
          echo "::add-mask::$NEW_PASSWORD"
          echo "password=$NEW_PASSWORD" >> $GITHUB_OUTPUT
      
      - name: Update secret in AWS Secrets Manager
        run: |
          # Get current secret
          current_secret=$(aws secretsmanager get-secret-value --secret-id production/database --query SecretString --output text)
          username=$(echo $current_secret | jq -r .username)
          
          # Update with new password
          aws secretsmanager update-secret \
            --secret-id production/database \
            --secret-string "{\"username\":\"$username\",\"password\":\"${{ steps.generate_password.outputs.password }}\"}" \
            --description "Password rotated on $(date -u +%Y-%m-%dT%H:%M:%SZ)"
      
      - name: Trigger External Secrets refresh
        run: |
          # Force refresh of ExternalSecret
          kubectl annotate externalsecret database-credentials \
            force-sync=$(date +%s) -n production --overwrite
          
          # Wait for secret to be updated
          kubectl wait --for=condition=Ready externalsecret/database-credentials -n production --timeout=60s
      
      - name: Rolling restart affected applications
        run: |
          # Get deployments that use the database secret
          deployments=$(kubectl get deployments -n production -o json | \
            jq -r '.items[] | select(.spec.template.spec.containers[].env[]?.valueFrom.secretKeyRef.name == "database-secret") | .metadata.name')
          
          for deployment in $deployments; do
            echo "Restarting deployment: $deployment"
            kubectl rollout restart deployment/$deployment -n production
            kubectl rollout status deployment/$deployment -n production --timeout=300s
          done
      
      - name: Verify database connectivity
        run: |
          # Test database connection using a job
          kubectl apply -f - <<EOF
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: db-connection-test-$(date +%s)
            namespace: production
          spec:
            template:
              spec:
                restartPolicy: Never
                containers:
                - name: test
                  image: postgres:15
                  command: ['sh', '-c']
                  args:
                  - |
                    pg_isready -h \$DB_HOST -U \$DB_USER
                    echo "Database connection successful"
                  env:
                  - name: DB_HOST
                    valueFrom:
                      secretKeyRef:
                        name: database-secret
                        key: host
                  - name: DB_USER
                    valueFrom:
                      secretKeyRef:
                        name: database-secret
                        key: username
                  - name: PGPASSWORD
                    valueFrom:
                      secretKeyRef:
                        name: database-secret
                        key: password
          EOF
          
          # Wait for job completion
          kubectl wait --for=condition=complete job -l batch.kubernetes.io/job-name --timeout=120s -n production

  rotate-api-keys:
    name: Rotate API Keys
    runs-on: ubuntu-latest
    needs: pre-rotation-checks
    if: needs.pre-rotation-checks.outputs.can_proceed == 'true' && (github.event.inputs.rotation_type == 'api-keys' || github.event.inputs.rotation_type == 'all')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }}
      
      - name: Rotate external service API keys
        run: |
          # Example: Rotate Slack API key
          NEW_SLACK_TOKEN=$(curl -s -X POST https://slack.com/api/auth.test \
            -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" | \
            jq -r '.ok // false')
          
          if [ "$NEW_SLACK_TOKEN" = "true" ]; then
            # Update secret in AWS Secrets Manager
            aws secretsmanager update-secret \
              --secret-id production/slack-api \
              --secret-string "{\"token\":\"${{ secrets.SLACK_BOT_TOKEN }}\",\"rotated_at\":\"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}"
            
            # Trigger External Secrets refresh
            kubectl annotate externalsecret slack-credentials \
              force-sync=$(date +%s) -n production --overwrite
          fi

  rotate-certificates:
    name: Rotate TLS Certificates
    runs-on: ubuntu-latest
    needs: pre-rotation-checks
    if: needs.pre-rotation-checks.outputs.can_proceed == 'true' && (github.event.inputs.rotation_type == 'certificates' || github.event.inputs.rotation_type == 'all')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }}
      
      - name: Rotate cert-manager certificates
        run: |
          # Force renewal of certificates that expire in 30 days
          kubectl get certificates -A -o json | \
            jq -r '.items[] | select(.status.notAfter | fromdateiso8601 < (now + 2592000)) | "\(.metadata.namespace) \(.metadata.name)"' | \
            while read namespace cert; do
              echo "Renewing certificate: $cert in namespace: $namespace"
              kubectl annotate certificate $cert cert-manager.io/issue-temporary-certificate="$(date +%s)" -n $namespace --overwrite
            done

  post-rotation-validation:
    name: Post-Rotation Validation
    runs-on: ubuntu-latest
    needs: [rotate-database-secrets, rotate-api-keys, rotate-certificates]
    if: always() && needs.pre-rotation-checks.outputs.can_proceed == 'true'
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }}
      
      - name: Health check post-rotation
        run: |
          echo "🔍 Checking application health post-rotation..."
          
          # Check deployment status
          kubectl get deployments -A --no-headers | while read namespace name ready uptodate available age; do
            if [ "$ready" != "$available" ]; then
              echo "❌ Deployment $name in $namespace is not ready: $ready/$available"
            else
              echo "✅ Deployment $name in $namespace is healthy: $ready/$available"
            fi
          done
          
          # Check external secrets status
          kubectl get externalsecrets -A -o json | \
            jq -r '.items[] | "\(.metadata.namespace) \(.metadata.name) \(.status.conditions[-1].status)"' | \
            while read namespace name status; do
              if [ "$status" = "True" ]; then
                echo "✅ ExternalSecret $name in $namespace is synced"
              else
                echo "❌ ExternalSecret $name in $namespace failed to sync"
              fi
            done
      
      - name: Create rotation report
        if: always()
        run: |
          cat > rotation-report.md << EOF
          # Secret Rotation Report
          
          **Date:** $(date -u +%Y-%m-%d)  
          **Time:** $(date -u +%H:%M:%S) UTC  
          **Rotation Type:** ${{ github.event.inputs.rotation_type || 'scheduled' }}
          
          ## Results
          
          - Database Secrets: ${{ needs.rotate-database-secrets.result }}
          - API Keys: ${{ needs.rotate-api-keys.result }}
          - Certificates: ${{ needs.rotate-certificates.result }}
          
          ## Application Status Post-Rotation
          
          \`\`\`
          $(kubectl get deployments -A --no-headers)
          \`\`\`
          
          ## External Secrets Status
          
          \`\`\`
          $(kubectl get externalsecrets -A --no-headers)
          \`\`\`
          EOF

  notify-completion:
    name: Notify Rotation Completion
    runs-on: ubuntu-latest
    needs: [post-rotation-validation]
    if: always()
    
    steps:
      - name: Send Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            🔄 **Secret Rotation Completed**
            
            **Type:** ${{ github.event.inputs.rotation_type || 'scheduled' }}
            **Status:** ${{ needs.post-rotation-validation.result }}
            **Time:** $(date -u)
            
            **Results:**
            - Database: ${{ needs.rotate-database-secrets.result }}
            - API Keys: ${{ needs.rotate-api-keys.result }}
            - Certificates: ${{ needs.rotate-certificates.result }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: Create GitHub issue on failure
        if: failure()
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🚨 Secret Rotation Failed',
              body: `
                ## Secret Rotation Failure Report
                
                **Date:** ${new Date().toISOString()}
                **Workflow:** ${context.workflow}
                **Run ID:** ${context.runId}
                
                ### Failed Jobs:
                ${{ toJSON(needs) }}
                
                ### Action Required:
                1. Review the failed workflow logs
                2. Check application health manually
                3. Verify secret synchronization
                4. Re-run rotation if necessary
                
                **Workflow URL:** ${context.payload.repository.html_url}/actions/runs/${context.runId}
              `,
              labels: ['bug', 'high-priority', 'security']
            });
